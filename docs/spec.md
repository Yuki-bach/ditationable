# dictationable アプリケーション仕様書（確定版）

## 1. 概要

### アプリ名
dictationable

### 目的
音声ファイルを話者分離して文字起こしするWebアプリケーション

### 主要機能
- 長時間音声ファイルの文字起こし
- 話者分離機能
- カスタマイズ可能なシステムプロンプト
- セキュリティ重視（非永続化）設計

## 2. 技術仕様

### 使用API
- **主要API**: Google Gemini API (gemini-2.0-flash)
- **設計方針**: 将来的に他のAI APIにも対応可能な抽象化設計

### Gemini API制約・仕様
- **対応音声形式**: WAV, MP3, AIFF, AAC, OGG Vorbis, FLAC, M4A
- **最大音声長**: 1プロンプトあたり9.5時間
- **トークン計算**: 音声1秒 = 32トークン
- **最大リクエストサイズ**: 20MB（インライン音声の場合）
- **音声解像度**: 16 Kbpsにダウンサンプリング
- **チャンネル**: マルチチャンネルは1チャンネルに統合
- **言語制限**: 英語音声のみ推奨

### システム制約
- データベース等への永続化は行わない
- すべての処理はメモリ上で完結
- 20MB超過時はFiles APIを使用

## 3. 機能要件

### 3.1 音声ファイル処理
- **対応形式**: WAV, MP3, AIFF, AAC, OGG Vorbis, FLAC, M4A
- **最大ファイルサイズ**:
  - インライン送信: 20MB以下
  - Files API使用: 9.5時間以下の音声長
- **処理方式**:
  - 20MB以下: インライン送信
  - 20MB超過: Files APIでアップロード
  - 9.5時間超過: 音声ファイル分割処理
- **話者分離**:
  - ユーザーが事前に話者数を設定可能
  - Geminiのシステムプロンプトで話者分離を指示
- **出力**: 話者別文字起こしテキスト（タイムスタンプ付き）

### 3.2 システムプロンプト設定
- ユーザーがGemini APIに送信するシステムプロンプトをカスタマイズ可能
- 話者分離用プロンプトテンプレートの提供
- タイムスタンプ形式（MM:SS）での区間指定対応

### 3.3 出力形式
- **テキスト形式（.txt）**: プレーンテキスト
- **JSON形式（.json）**:
  ```json
  {
    "speakers": [
      {
        "speaker_id": "Speaker 1",
        "segments": [
          {
            "timestamp": "00:15",
            "text": "発言内容"
          }
        ]
      }
    ]
  }
  ```

### 3.4 セキュリティ要件
- 音声ファイルはアップロード後、処理完了と同時に削除
- 文字起こし結果はセッション終了時に破棄
- **APIキー管理**:
  - クライアントサイドで環境変数として管理
  - ローカルストレージには保存しない
  - HTTPSでの通信必須
  - APIキー入力時のマスク表示
  - 不正なAPIキーの検証とエラーハンドリング

## 4. 非機能要件

### 4.1 拡張性
- API抽象化層の実装
- 将来的なAI API追加に対応可能な設計

### 4.2 パフォーマンス
- 9.5時間超過音声ファイルの効率的な分割処理
- リアルタイムプログレス表示（進行率、処理時間予測）
- 非同期処理による UI の応答性維持

### 4.3 ユーザビリティ
- 直感的なUI/UX
- 処理状況の可視化

## 5. システム構成・技術実装方針

### 推奨デプロイ環境: Vercel
- **フロントエンド**: Next.js (App Router)
- **バックエンド**: Vercel Serverless Functions
- **音声処理**: クライアントサイド（ffmpeg.wasm）+ サーバーサイド補助

### 開発環境: Docker
- **コンテナ化**: Docker + Docker Compose による開発環境統一
- **Node.js環境**: node:18-alpine ベースイメージ
- **ホットリロード**: ボリュームマウントによる開発効率化
- **環境分離**: ホストマシンを汚さないクリーンな開発環境

### Docker構成
```yaml
# docker-compose.yml
version: '3.8'
services:
  dictationable:
    build:
      context: .
      dockerfile: Dockerfile.dev
    ports:
      - "3000:3000"
    volumes:
      - .:/app
      - /app/node_modules
    environment:
      - NODE_ENV=development
    command: npm run dev
```

```dockerfile
# Dockerfile.dev
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 3000
CMD ["npm", "run", "dev"]
```

### デプロイフロー
1. **開発**: Docker環境でローカル開発
2. **プッシュ**: GitリポジトリにコミットPush
3. **デプロイ**: Vercelが自動的にデプロイ（Dockerファイルは無視）

### 音声ファイル分割の技術的アプローチ

#### 方針1: ffmpeg.wasm（推奨）
ffmpeg.wasmは純粋なWebAssembly/JavaScriptのFFmpegポートで、ブラウザ内で直接音声・動画の録音、変換、ストリーミングが可能

**メリット**:
- セキュリティ: ユーザーのデータはブラウザ内にのみ存在し、データ漏洩やネットワーク遅延を心配する必要がない
- クライアントサイド処理: サーバークラスターをホストする代わりに、マルチメディア処理をクライアントサイドにオフロードできる
- ffmpeg -i input.wav -f segment -segment_time 600 -c copy output_%03d.wav のようなコマンドで等間隔分割が可能

**デメリット**:
- ファイルサイズが約20MB（音声専用版は5MB）
- 現時点でFFmpeg WASMは2倍遅く、不安定な場合がある

#### 方針2: Web Audio API + 手動分割（補助的）
Web Audio APIは、Webでオーディオを制御するための強力で多様なシステムを提供

**使用ケース**:
- 音声ファイルの基本的な情報取得（長さ、チャンネル数等）
- 20MB以下のファイルでGemini制限内の場合の処理

#### 方針3: サーバーサイド処理（フォールバック）
- 非常に大きなファイル（ffmpeg.wasmで処理困難）
- Vercel Serverless Functionsでffmpegを実行

### アーキテクチャ設計

```
クライアント（Next.js）
├── 音声ファイルアップロード
├── ファイルサイズ・時間長チェック
├── 分割処理判定
│   ├── 9.5時間以下 + 20MB以下 → 直接Gemini送信
│   ├── 9.5時間以下 + 20MB超過 → Files API使用
│   └── 9.5時間超過 → ffmpeg.wasmで分割
└── 結果表示・ダウンロード

サーバー（Vercel Functions）
├── Gemini API統合
├── 大容量ファイル処理（必要時）
└── APIキー検証
```

## 6. 想定される課題・検討事項

### 6.1 API制限対応
- 9.5時間制限を超える音声の分割処理
- レート制限への対応（バックオフ戦略）
- Files APIのファイル管理（アップロード後の削除）

### 6.2 音声ファイル分割の技術課題
- **ffmpeg.wasmの制約**:
  - ファイルサイズ約20MB（音声専用版5MB）のダウンロードが必要
  - 処理速度がネイティブffmpegの約2倍遅い
  - 安定性の問題（一部のMOVファイル等で失敗する場合）
- **最適な分割方法**:
  - 無音検出による自然な分割ポイントの特定
  - 話者変更点での分割（話者分離精度を維持）
  - 等間隔分割（570秒 = 9.5時間の分割）の実装
- **分割されたセグメント間の話者IDの一貫性維持**

### 6.3 エラーハンドリング
- API障害時の対応とリトライ機能
- 大容量ファイル処理時のメモリ管理
- 不正な音声形式の検証
- ネットワーク切断時の処理復旧

## 7. APIキーセキュリティ要件

### 7.1 必須セキュリティ対策
- **HTTPS通信**: すべての通信でHTTPS必須
- **APIキー管理**:
  - セッションメモリ内のみ保存
  - ローカルストレージ/セッションストレージ使用禁止
  - 入力時のマスク表示（type="password"）
  - ブラウザ開発者ツールでの非表示化

### 7.2 実装セキュリティ
- **APIキー検証**: 不正なキーの事前チェック
- **エラーハンドリング**: APIキーエラー時の適切なメッセージ表示
- **リクエスト制限**: 同一セッション内での過度なリクエスト防止
- **CORS設定**: 適切なオリジン制限

## 8. 実装時の技術的考慮事項

### 8.1 開発環境セットアップ要件
- **Docker環境**:
  - Docker Desktop インストール必須
  - Node.js 18 Alpine ベースイメージ使用
  - ボリュームマウントによるホットリロード対応
- **ffmpeg.wasmセットアップ要件**:
  - **CORS設定**: WebAssemblyモジュールを使用するためにCORSを正しく構成する必要
  - **必要ヘッダー（next.config.js）**:
    ```javascript
    async headers() {
      return [{
        source: '/(.*)',
        headers: [
          { key: 'Cross-Origin-Opener-Policy', value: 'same-origin' },
          { key: 'Cross-Origin-Embedder-Policy', value: 'require-corp' },
          { key: 'Cross-Origin-Resource-Policy', value: 'cross-origin' }
        ]
      }]
    }
    ```
  - **SharedArrayBuffer対応**: 先進的なWeb APIを使用するため最新ブラウザが必要

### 8.2 パフォーマンス最適化
- **Web Worker使用**: メインスレッドをブロックしないよう音声処理をWeb Workerで実行
- **プログレッシブ処理**: 大容量ファイルのストリーミング分割処理
- **メモリ管理**: 処理完了後のバッファクリーンアップ

### 8.3 エラーハンドリング戦略
- **段階的フォールバック**:
  1. ffmpeg.wasmでの処理試行
  2. 失敗時はWeb Audio APIでの基本分割
  3. 最終的にサーバーサイド処理
- **ユーザーフレンドリーなエラーメッセージ**
- **処理状況の詳細表示**（ダウンロード、初期化、処理、完了）

### 8.5 開発環境の利点
- **環境統一**: チーム開発時の Node.js バージョンや依存関係の差異を防止
- **クリーン開発**: ホストマシンを汚さず、プロジェクト間の依存関係衝突を回避
- **CI/CD統合**: 本番環境と同じコンテナ環境でテスト実行
- **スケーラビリティ**: 将来的な追加サービス（Redis、DB等）の統合が容易
